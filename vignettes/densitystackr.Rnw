\documentclass[fleqn]{article}

\usepackage{geometry}
\geometry{letterpaper, top=1.5cm, left=2cm, right=2cm}

\usepackage{amssymb, amsmath, amsfonts}


\include{GrandMacros}

\newcommand{\cdf}{{c.d.f.} }
\newcommand{\pdf}{{p.d.f.} }
\newcommand{\ind}{\mathbb{I}}
\newcommand{\logsum}{\bigoplus}

\begin{document}


\section{Loss Function and its Derivatives: Smoothing Splines}

In this Section, we write down the math for estimation via splines.
We will use the symbol $\logsum$ to denote the log-space summation operator:
$\logsum_{i = 1}^N \log(a_i) = \log\left(\sum_{i = 1}^N a_i\right)$.
Writing expressions using this notation will allow us to obtain numerically
stable computational expressions.

Let $m \in \{1, \ldots, M\}$ index component predictive models and
$i \in \{1, \ldots, N\}$ index prediction cases in the training data.
For example, in a seasonal time series prediction context $i$ may index
times at which we make predictions for seasonal quantities, or combination of
a time at which we make a prediction and the prediction horizon for predictions
at individual weeks.  Let $f_{m}(y_i | \bx_i)$ denote the predictive density
from model $m$ for the value of the random variable $Y_i$.  The $\bx_i$ is a
vector observed covariates which may be used by any of the component models
as conditioning variables in forming the predictive distribution, and is also
used in calculating the component model weights.  Note that the component models
and computation of the component model weights may use a proper subset of the
variables in $\bx_i$.

The combined predictive density for case $i$ is
\begin{align}
f(y_i | \bx_i) &= \sum_{m = 1}^M \pi_{m}(\bx_i) f_{m}(y_i | \bx_i) \text{, where} \label{eqn:EnsembleModel} \\
\pi_{m}(\bx_i) &= \frac{\exp\{\sum_{j = 1}^J s_{mj}(x_{ij})\}}{\exp\{\sum_{m' = 1}^M \sum_{j = 1}^J s_{m'j}(x_{ij})\}} \label{eqn:PiMultilogitSplines} \\
&= \frac{\exp(\sum_{j = 1}^J B'_{ij} \btheta_{mj})}{\exp(\sum_{m' = 1}^M \sum_{j = 1}^J B'_{ij} \btheta_{m'j})} \label{eqn:PiMultilogitSplinesMatrixForm}
\end{align}
In Equation~\eqref{eqn:EnsembleModel} the $\pi_m(\bx_i)$ are the model weights,
which we regard as functions of $\bx_i$.  These weights must be non-negative and
sum to $1$ across $m$.  We ensure that these constraints are met by
parameterizing the $\pi_m(\bx_i)$ in terms of the softmax transformation of
a separate smoothing spline for each covariate in Equation~\eqref{eqn:PiMultilogitSplines}.
Equation~\eqref{eqn:PiMultilogitSplinesMatrixForm} represents the spline
function $s_{mj}$ for the $m$th model and $j$th covariate evaluated at $x_{ij}$
as the product of a vector $B'_{ij}$ of B-spline basis functions evaluated at
$x_{ij}$ and a corresponding vector $\btheta_{mj}$ of coefficients.

As usual with smoothing splines, we proceed with estimation of the coefficient
vectors $\btheta_{mj}$ under a penalty on the integrated second derivative of
the spline functions.  We use a penalty $\lambda_j$ for each covariate $j$ that
is shared across all values of $m$, so that $\lambda_j$ effectively controls the
smoothness of the weighting function as the $j$th covariate varies.

Putting these pieces together, the penalized loss function used in estimation is
\begin{align}
\ell(\btheta) &= \sum_{i=1}^N \log\{f(y_i | \bx_i)\} - \frac{1}{2} \sum_j \lambda_j \sum_m \int \left\{s''(x)\right\} \mathrm{d}x \\
&= \sum_{i=1}^N \log \left\{ \sum_{m = 1}^M \pi_{mi} f_{m}(y_i | \bx_i) \right\} - \frac{1}{2} \sum_j \lambda_j \sum_m \btheta'_{mj} \Omega_{j} \btheta_{mj} \\
&= \sum_{i=1}^N \log \left\{ \sum_{m = 1}^M \frac{\exp(\sum_{j = 1}^J B'_{ij} \btheta_{mj})}{\sum_{m' = 1}^M \exp(\sum_{j = 1}^J B'_{ij} \btheta_{m'j})} f_{m}(y_i | \bx_i) \right\} - \frac{1}{2} \sum_j \lambda_j \sum_m \btheta'_{mj} \Omega_{j} \btheta_{mj}
\end{align}

In order to estimate $\btheta$, we will use the backfitting algorithm that is
standard for estimating generalized additive models.  This can alternatively be
conceptualized as optimizing the penalized loss via a block update algorithm,
where we update the parameters $\btheta_{mj}$ for one spline at a time.
To do this, we will use a Newton update in each step:
\begin{equation}
\btheta_{mj}^{\text{new}} = \btheta_{mj}^{\text{old}} - \left\{\frac{\partial^2 \ell(\btheta)}{\partial \btheta_{mj} \partial \btheta'_{mj}}\right\}^{-1} \frac{\partial \ell(\btheta)}{\partial \btheta_{mj}}, \label{eqn:NRParamUpdate}
\end{equation}
where the partial derivatives are taken at $\btheta_{mj}^{\text{old}}$.

To proceed, we must calculate the gradient and Hessian of the likelihood function
with respect to a particular set of spline parameters which we will denote by
$\btheta_{m^*j^*}$.

It will be helpful to obtain the preliminary results that
\begin{align}
\frac{\partial \pi_{m^*i}}{\partial \btheta_{m^*j^*}} &= \frac{\partial }{\partial \btheta_{m^*j^*}} \frac{\exp(\sum_{j = 1}^J B'_{ij} \btheta_{m^*j})}{\exp(\sum_{m' = 1}^M \sum_{j = 1}^J B'_{ij} \btheta_{m'j})} \nonumber \\
&= \frac{\exp(\sum_{j = 1}^J B'_{ij} \btheta_{m^*j}) \left\{\sum_{m' = 1}^M \exp(\sum_{j = 1}^J B'_{ij} \btheta_{m'j})\right\} B_{ij^*} -  \left\{\exp(\sum_{j = 1}^J B'_{ij} \btheta_{m^*j})\right\}^2 B_{ij^*} }{\left\{\sum_{m' = 1}^M \exp(\sum_{j = 1}^J B'_{ij} \btheta_{m'j})\right\}^2} \nonumber \\
&= (\pi_{m^*i} - \pi_{m^*i}^2) B_{ij^*},
\end{align}
while for $m \neq m^*$
\begin{align}
\frac{\partial \pi_{mi}}{\partial \btheta_{m^*j^*}} &= \frac{\partial }{\partial \btheta_{m^*j^*}} \frac{\exp(\sum_{j = 1}^J B'_{ij} \btheta_{mj})}{\exp(\sum_{m' = 1}^M \sum_{j = 1}^J B'_{ij} \btheta_{m'j})} \nonumber \\
&= \frac{ -  \exp(\sum_{j = 1}^J B'_{ij} \btheta_{mj}) \exp(\sum_{j = 1}^J B'_{ij} \btheta_{m^*j}) B_{ij^*} }{\left\{\sum_{m' = 1}^M \exp(\sum_{j = 1}^J B'_{ij} \btheta_{m'j})\right\}^2} \nonumber \\
&= (- \pi_{m^*i} \pi_{mi}) B_{ij^*}.
\end{align}

We now calculate the gradient as
\begin{align}
\frac{\partial \ell(\btheta)}{\partial \btheta_{m^*j^*}} &=
  \frac{\partial}{\partial \btheta_{m^*j^*}} \left[ \sum_{i=1}^N \log \left\{ \sum_{m = 1}^M \pi_{mi} f_{m}(y_i | \bx_i) \right\} - \frac{1}{2} \sum_j \lambda_j \sum_m \btheta'_{mj} \Omega_{j} \btheta_{mj} \right] \nonumber \\
&= \sum_{i=1}^N \frac{1}{f(y_i | x_i)} \left\{ \pi_{m^*i}f_{m^*}(y_i | x_i) - \sum_{m = 1}^M \pi_{mi} \pi_{m^*i} f_m(y_i | x_i) \right\} B_{ij^*} - \lambda_{j^*} \Omega_{j^*} \btheta_{m^*j^*} \nonumber \\
&= \sum_{i=1}^N \pi_{m^*i} \left\{ \frac{f_{m^*}(y_i | x_i)}{f(y_i | x_i)} - 1 \right\} B_{ij^*} - \lambda_{j^*} \Omega_{j^*} \btheta_{m^*j^*} \nonumber \\
&= B'_{j^*} \bg - \lambda_{j^*} \Omega_{j^*} \btheta_{m^*j^*}. \label{eqn:LossSplinesGradWRTTheta}
\end{align}

In Equation~\eqref{eqn:LossSplinesGradWRTTheta}, $B_{j^*}$ is an $N \times D_{j^*}$
matrix with the $D_{j^*}$ spline basis functions for covariate $j^*$ evaluated
at each observation $i = 1, \ldots, N$.  $\bg$ is a column vector of length $N$
where entry $i$ is $\pi_{m^*i} \left\{ \frac{f_{m^*}(y_i | x_i)}{f(y_i | x_i)} - 1 \right\}$.
This quantity has the interpretation that the contribution to the gradient from
observation $i$ is positive if the conditional density for $Y_i | X_i$ from
model $m^*$ was larger at the observed outcome $y_i$ than the combined
conditional density after the previous iteration.

We can calculate the Hessian as
\begin{align}
&\frac{\partial^2 \ell(\btheta)}{\partial \btheta_{m^*j^*} \partial \btheta'_{m^*j^*}} =
  \frac{\partial \ell(\btheta)}{\partial \btheta'_{m^*j^*}} \left[ \sum_{i=1}^N B_{ij^*} \pi_{m^*i} \left\{ \frac{f_{m^*}(y_i | x_i)}{f(y_i | x_i)} - 1 \right\} - \lambda_{j^*} \Omega_{j^*} \btheta_{m^*j^*} \right] \\
&\qquad = \frac{\partial \ell(\btheta)}{\partial \btheta'_{m^*j^*}} \left[ \sum_{i=1}^N B_{ij^*} \left\{ \frac{\pi_{m^*i} f_{m^*}(y_i | x_i)}{\sum_{m' = 1}^M \pi_{m'i} f_{m'}(y_i | x_i)} - \pi_{m^*i} \right\} - \lambda_{j^*} \Omega_{j^*} \btheta_{m^*j^*} \right] \\
&\qquad = \sum_{i=1}^N B_{ij^*} \left\{ \frac{(\pi_{m^*i} - \pi_{m^*i}^2 ) f_{m^*}(y_i | x_i) \left\{\sum_{m' = 1}^M \pi_{m'i} f_{m'}(y_i | x_i)\right\} B'_{ij^*} }{\left\{\sum_{m' = 1}^M \pi_{m'i} f_{m'}(y_i | x_i)\right\}^2} \right. \\
&\qquad \qquad \qquad \qquad \qquad \qquad - \left. \frac{\pi_{m^*i}^2 f_{m^*}(y_i | x_i) \left\{ f_{m^*}(y_i | x_i) - \sum_{m' = 1}^M \pi_{m'i} f_{m'}(y_i | x_i) \right\} B'_{ij^*} }{\left\{\sum_{m' = 1}^M \pi_{m'i} f_{m'}(y_i | x_i)\right\}^2} \right. \\
&\qquad \qquad \qquad \qquad \qquad \qquad \left. - (\pi_{m^*i} - \pi_{m^*i}^2 ) B'_{ij^*} \vphantom{\frac{(\pi_{m^*i} - \pi_{m^*i}^2 ) \left\{\sum_{m' = 1}^M \pi_{m'i} f_{m'}(y_i | x_i)\right\} B'_{ij^*} - \pi_{m^*i}^2 \left\{ 1 - \sum_{m' = 1}^M \pi_{m'i} f_{m'}(y_i | x_i) \right\} B'_{ij^*} }{\left\{\sum_{m' = 1}^M \pi_{m'i} f_{m'}(y_i | x_i)\right\}^2}} \right\} - \lambda_{j^*} \Omega_{j^*} \\
&\qquad = \sum_{i=1}^N B_{ij^*} \left[ \pi_{m^*i} \left\{\frac{f_{m*}(y_i | x_i)}{f(y_i | x_i)} - 1 \right\} - \pi_{m^*i}^2 \left\{ \left(\frac{f_{m*}(y_i | x_i)}{f(y_i | x_i)}\right)^2 - 1 \right\} \right] B'_{ij^*} - \lambda_{j^*} \Omega_{j^*} \\
&\qquad = - B'_{j^*} W B_{j^*} - \lambda_{j^*} \Omega_{j^*}.
\end{align}

% d^2/dx^2 ln( (exp(f * x + g)/(exp(f * x + g) + exp(a) + exp(b))) * c + (exp(a)/(exp(f * x + g) + exp(a) + exp(b))) * d + (exp(b)/(exp(f * x + g) + exp(a) + exp(b))) * e )


Here, $f(y_i | x_i)$ is the combined predictive density from the ensemble using
the model weights obtained after the previous iteration of the parameter updating
algorithm.  $W$ is an $N \times N$ diagonal matrix where the $i$th entry on the
diagonal is
$\left[ \pi_{m^*i}^2 \left\{ \left(\frac{f_{m*}(y_i | x_i)}{f(y_i | x_i)}\right)^2 - 1 \right\} - \pi_{m^*i} \left\{\frac{f_{m*}(y_i | x_i)}{f(y_i | x_i)} - 1 \right\} \right]$.
In general these values may be negative, and the Hessian is not guaranteed to be
positive definite (particularly if $\lambda_{j^*}$ is close to $0$).  In that
case, the Newton update of Equation~\eqref{eqn:NRParamUpdate} is not appropriate
since the update may not move in an ascent direction (cite Nocedal and Wright).
In such cases, it is standard procedure to modify the Hessian to ensure that it
is positive definite.  In this case, this can be achieved by truncating the
diagonal entries of $W$ below at $\delta > 0$; we have used $\delta = 1$.
This choice for $\delta$ is conservative and may reduce the convergence rate of
the estimation procedure; we have not explored other possible values for $\delta$.

Now returning to Equation~\eqref{eqn:NRParamUpdate}, the updated parameters in
each iteration of the Newton-Raphson optimization procedure are obtained as
\begin{align}
&\btheta_{mj}^{\text{new}} = \btheta_{mj}^{\text{old}} - \left\{\frac{\partial^2 \ell(\btheta)}{\partial \btheta_{mj} \partial \btheta'_{mj}}\right\}^{-1} \frac{\partial \ell(\btheta)}{\partial \btheta_{mj}} \\
&\qquad = \btheta_{mj}^{\text{old}} - \left\{ - B'_{j^*} W B_{j^*} - \lambda_{j^*} \Omega_{j^*} \right\}^{-1} \left\{ B'_{j^*} \bg - \lambda_{j^*} \Omega_{j^*} \btheta^{\text{old}}_{m^*j^*} \right\} \\
&\qquad = \left\{ B'_{j^*} W B_{j^*} + \lambda_{j^*} \Omega_{j^*} \right\}^{-1} \left\{ B'_{j^*} \bg + B'_{j^*} W B_{j^*} \btheta^{\text{old}}_{m^*j^*} \right\} \label{eqn:NRUpdateSubstitute} \\
&\qquad = \left\{ B'_{j^*} W B_{j^*} + \lambda_{j^*} \Omega_{j^*} \right\}^{-1} B'_{j^*} W \left\{ W^{-1} \bg + B_{j^*} \btheta^{\text{old}}_{m^*j^*} \right\} \label{eqn:NRUpdateFinal}
\end{align}

In Equation~\eqref{eqn:NRUpdateSubstitute}, we have used the fact that
$\btheta^{\text{old}}_{m^*j^*} = \left\{ B'_{j^*} W B_{j^*} + \lambda_{j^*} \Omega_{j^*} \right\}^{-1} \left\{ B'_{j^*} W B_{j^*} + \lambda_{j^*} \Omega_{j^*} \right\} \btheta^{\text{old}}_{m^*j^*}$, so
$\btheta^{\text{old}}_{m^*j^*} - \left\{ B'_{j^*} W B_{j^*} + \lambda_{j^*} \Omega_{j^*} \right\}^{-1} \lambda_{j^*} \Omega_{j^*} \btheta^{\text{old}}_{m^*j^*} = \left\{ B'_{j^*} W B_{j^*} + \lambda_{j^*} \Omega_{j^*} \right\}^{-1} B'_{j^*} W B_{j^*} \btheta^{\text{old}}_{m^*j^*}.$
The updated estimates $\btheta_{mj}^{\text{new}}$ from
Equation~\eqref{eqn:NRUpdateFinal} have the form of parameter estimates from a
smoothing spline where the observations have weights specified by the elements
of $W$ and the "working response" vector is given by
$W^{-1} \bg + B_{j^*} \btheta^{\text{old}}_{m^*j^*}$.  It is informative to
observe that the second term in this working response is the fitted spline value
after the previous parameter update step, and the first term specifies that the
parameters should be updated so as to move the spline fit in the direction of
the vector $\bg$ of contributions to the gradient from each observation,
scaled by the inverse of the observation weights in $W$.

\section{Loss Function and its Derivatives: Boosting}

In this Section, we write down the math.  We will use the symbol $\logsum$ to denote the log-space summation operator: $\logsum_{i = 1}^N \log(a_i) = \log\left(\sum_{i = 1}^N a_i\right)$.  Writing expressions using this notation will allow us to obtain numerically stable computational expressions.

Let $m \in \{1, \ldots, M\}$ index component predictive models and $i \in \{1, \ldots, N\}$ index prediction cases in the training data.  For example, in a seasonal time series prediction context $i$ may index times at which we make predictions for seasonal quantities, or combination of a time at which we make a prediction and the prediction horizon for predictions at individual weeks.  Let $f_{m}(y_i | \bx_i)$ denote the predictive density from model $m$ for the value of the random variable $Y_i$.  The $\bx_i$ is a vector observed covariates which may be used by any of the component models as conditioning variables in forming the predictive distribution, and is also used in calculating the component model weights.  Note that the component models and computation of the component model weights may use a proper subset of the variables in $\bx_i$.

The combined predictive density for case $i$ is
\begin{align}
f(y_i | \bx_i) &= \sum_{m = 1}^M \pi_{m}(\bx_i) f_{m}(y_i | \bx_i) \text{, where} \label{eqn:EnsembleModel} \\
\pi_{m}(\bx_i) &= \frac{\exp\{\rho_m(\bx_i)\}}{\sum_{m' = 1}^M \exp\{\rho_{m'}(\bx_i)\}} \label{eqn:PiMultilogitRho}
\end{align}
In Equation~\eqref{eqn:EnsembleModel} the $\pi_m(\bx_i)$ are the model weights, which we regard as functions of $\bx_i$.  These weights must be non-negative and sum to $1$ across $m$.  We ensure that these constraints are met by parameterizing the $\pi_m(\bx_i)$ in terms of the softmax transformation of real-valued functions $\rho_m(\bx_i)$ in Equation~\eqref{eqn:PiMultilogitRho}.  For notational brevity, we will suppress the expression of these quantities as functions of $\bx_i$ and write $\rho_m(\bx_i) = \rho_{mi}$ with $\brho = (\rho_{11}, \ldots, \rho_{MN})$, and $\pi_m(\bx_i) = \pi_{mi}$ with $\bpi = (\pi_{11}, \ldots, \pi_{MN})$.

Our goal is to estimate the functions $\rho_{mi}$.  To do this, we require as inputs cross-validated estimates of $\log\{f_m(y_i | \bx_i)\}$ for each component model $m$ and case $i$ in the training data; we denote these values by $\log\{f^{cv}_m(y_i | \bx_i)\}$.  We will focus on optimization of the log-score of the combined predictive distribution for now; we may consider other loss functions in the future.  Considered as a function of the vector of values $\rho_{mi}$ for each combination of $m$ and $i$, this loss function is given by

\begin{align}
L(\brho) &= \sum_{i=1}^N \log\{f(y_i | \bx_i)\} \\
&= \sum_{i=1}^N \log \left\{ \sum_{m = 1}^M \pi_{mi} f_{m}(y_i | \bx_i) \right\} \\
&= \sum_{i=1}^N \log \left\{ \sum_{m = 1}^M \frac{\exp(\rho_{mi})}{\sum_{m' = 1}^M \exp(\rho_{m'i})} f_{m}(y_i | \bx_i) \right\}
\end{align}

We must find the first and second order partial derivatives of $L$ with respect to each $\rho_{m^*i^*}$.

\begin{align}
\frac{\partial}{\partial \rho_{m^*i^*}} L(\brho) &= \frac{\partial}{\partial \rho_{m^*i^*}} \sum_{i=1}^N \log \left\{ \sum_{m = 1}^M \frac{\exp(\rho_{mi})}{\sum_{m' = 1}^M \exp(\rho_{m'i})} f_{m}(y_i | \bx_i) \right\} \\
&= \left\{ \frac{1}{ \sum_{m = 1}^M \frac{\exp(\rho_{mi^*})}{\sum_{m' = 1}^M \exp(\rho_{m'i^*})} f_{m}(y_{i^*} | \bx_{i^*}) } \right\} \times \frac{\partial}{\partial \rho_{m^*i^*}} \sum_{m = 1}^M \frac{\exp(\rho_{mi^*})}{\sum_{m' = 1}^M \exp(\rho_{m'i^*})} f_{m}(y_{i^*} | \bx_{i^*}) \label{eqn:PartialLPartialRhoFirstStep}
\end{align}

Now note that for $m^* = m$,
\begin{align*}
\frac{\partial}{\partial \rho_{m^*i^*}} \pi_{mi^*} &= \frac{\partial}{\partial \rho_{m^*i^*}} \frac{\exp(\rho_{mi^*})}{\sum_{m' = 1}^M \exp(\rho_{m'i^*})} \\
&= \frac{\exp(\rho_{mi^*})\left\{\sum_{m' = 1}^M \exp(\rho_{m'i^*})\right\} - \exp(\rho_{mi^*})^2}{\left\{\sum_{m' = 1}^M \exp(\rho_{m'i^*})\right\}^2} \\
&= \pi_{mi^*} - \pi_{mi^*}^2.
\end{align*}

For $m^* \neq m$,
\begin{align*}
\frac{\partial}{\partial \rho_{m^*i^*}} \pi_{mi^*} &= \frac{\partial}{\partial \rho_{m^*i^*}} \frac{\exp(\rho_{mi^*})}{\sum_{m' = 1}^M \exp(\rho_{m'i^*})} \\
&= \frac{- \exp(\rho_{mi^*})\exp(\rho_{m^*i^*})}{\left\{\sum_{m' = 1}^M \exp(\rho_{m'i^*})\right\}^2} \\
&= - \pi_{mi^*}\pi_{m^*i^*}.
\end{align*}

Substituting these results into Equation~\eqref{eqn:PartialLPartialRhoFirstStep}, we obtain
\begin{align}
\frac{\partial}{\partial \rho_{m^*i^*}} L(\brho) &= \left\{ \frac{1}{ \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*}) } \right\} \left\{\pi_{m^*i^*}\left(f_{m^*}(y_{i^*} | \bx_{i^*}) - \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*}) \right) \right\} \\
&= \frac{\pi_{m^*i^*}f_{m^*}(y_{i^*} | \bx_{i^*})}{ \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*}) } - \pi_{m^*i^*}
\end{align}
% Verified on Wolfram Alpha via
% d/dx ln( (exp(x)/(exp(x) + exp(a) + exp(b))) * c + (exp(a)/(exp(x) + exp(a) + exp(b))) * d + (exp(b)/(exp(x) + exp(a) + exp(b))) * e )

Now, we calculate the second order derivative as

\begin{align}
\frac{\partial^2}{\partial \rho_{m^*i^*}^2} L(\brho) &= \frac{\partial}{\partial \rho_{m^*i^*}} \left[ \frac{\partial}{\partial \rho_{m^*i^*}} L(\brho) \right] \\
&= \frac{\partial}{\partial \rho_{m^*i^*}} \left[ \frac{\pi_{m^*i^*}f_{m^*}(y_{i^*} | \bx_{i^*})}{ \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*}) } - \pi_{m^*i^*} \right] \\
&= \frac{\left(\pi_{m^*i^*} - \pi_{m^*i^*}^2\right)f_{m^*}(y_{i^*} | \bx_{i^*}) \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*})}{\left\{ \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*}) \right\}^2} \\
&\qquad - \frac{\pi_{m^*i^*}f_{m^*}(y_{i^*} | \bx_{i^*})
\left\{\pi_{m^*i^*}\left(f_{m^*}(y_{i^*} | \bx_{i^*}) - \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*}) \right) \right\}
}{\left\{ \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*}) \right\}^2} \\
&\qquad - \left(\pi_{m^*i^*} - \pi_{m^*i^*}^2\right) \\
&= \left(1 - \pi_{m^*i^*}\right) \frac{\pi_{m^*i^*}f_{m^*}(y_{i^*} | \bx_{i^*}) }{ \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*})} \\
&\qquad - \left[\frac{\pi_{m^*i^*}f_{m^*}(y_{i^*} | \bx_{i^*})}{\sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*})}\right]^2 + \pi_{m^*i^*} \frac{\pi_{m^*i^*}f_{m^*}(y_{i^*} | \bx_{i^*})}{\sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*})} \\
&\qquad - \left(\pi_{m^*i^*} - \pi_{m^*i^*}^2\right) \\
&= \frac{\pi_{m^*i^*}f_{m^*}(y_{i^*} | \bx_{i^*}) }{ \sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*})} - \left[\frac{\pi_{m^*i^*}f_{m^*}(y_{i^*} | \bx_{i^*})}{\sum_{m = 1}^M \pi_{mi^*} f_{m}(y_{i^*} | \bx_{i^*})}\right]^2 - \left(\pi_{m^*i^*} - \pi_{m^*i^*}^2\right)
\end{align}

% Verified on Wolfram Alpha via
% d^2/dx^2 ln( (exp(x)/(exp(x) + exp(a) + exp(b))) * c + (exp(a)/(exp(x) + exp(a) + exp(b))) * d + (exp(b)/(exp(x) + exp(a) + exp(b))) * e )


\section{Simulated Application}

<<SimulatedApplication, eval = TRUE, cache = TRUE>>=
library(plyr)
library(tidyr)
library(dplyr)
library(densitystackr)
library(ggplot2)
library(awes)

### For now, let's just make up some data for the purposes of method development
### this will need to go into test code too
set.seed(9873)
loso_pred_res <- data.frame(
  model = paste0("log_score_", rep(letters[1:3], each = 100)),
  d = rep(1:100, times = 3),
  loso_log_score = c(
    log(runif(100, 0, 1)), # model a's performance not related to d
    sort(log(runif(100, 0, 1))), # model b's performance increasing in d
    rep(-0.5, 100))  # model c's performance constant
) %>%
  spread(model, loso_log_score) %>%
  mutate(e = rnorm(100))

## Obtain stacking model fit
#debug(density_stack_splines_fixed_regularization)
fit_time <- system.time({
  stacking_fit <- density_stack_splines_fixed_regularization(
    log_score_a + log_score_b + log_score_c ~ d,
    data = loso_pred_res,
    lambda = 1,
    tol = 10^{-4},
    maxit = 10^5,
    verbose = 0)
})

cat(fit_time)

require(doMC)
registerDoMC(4)

#debug(density_stack)
fit_time_cv_reg <- system.time({
  stacking_fit_cv_reg <- density_stack(
    log_score_a + log_score_b + log_score_c ~ d,
    data = loso_pred_res,
    df = data.frame(d = seq(from = 3, by = 3, length = 10)),
    min_obs_weight = 1,
    tol = 10^{-3},
    maxit = 10^5,
    cv_folds = NULL,
    cv_nfolds = 10L,
    verbose = 1)
})

## Make a plot
component_model_scores_df <- as.data.frame(as.matrix(
      loso_pred_res[, paste0("log_score_", letters[1:3]), drop = FALSE]
    ) %>%
    `storage.mode<-`("double")) %>%
  `colnames<-`(letters[1:3]) %>%
  gather_("model", "score", letters[1:3]) %>%
  mutate(d = rep(1:100, 3))

component_model_weights_df <-
  compute_model_weights(stacking_fit,
    newdata = data.frame(d = 1:100),
    log = FALSE) %>%
  as.data.frame() %>%
  `colnames<-`(letters[1:3]) %>%
  gather_("model", "weight", letters[1:3]) %>%
  mutate(d = rep(1:100, 3))

component_model_weights_df_cv_reg <-
  compute_model_weights(stacking_fit_cv_reg,
    newdata = data.frame(d = 1:100),
    log = FALSE) %>%
  as.data.frame() %>%
  `colnames<-`(letters[1:3]) %>%
  gather_("model", "weight", letters[1:3]) %>%
  mutate(d = rep(1:100, 3))

ggplot() +
  geom_point(aes(x = d, y = score, colour = model), data = component_model_scores_df) +
  geom_point(aes(x = d, y = weight, colour = model), alpha = 0.5, shape = 15, data = component_model_weights_df) +
  geom_point(aes(x = d, y = weight, colour = model), shape = 15, data = component_model_weights_df_cv_reg)
@


\section{Real Application}

<<NationalOnsetWeekFit, eval = TRUE, cache = TRUE>>=
region <- "National"
prediction_target <- "onset"
explanatory_variables <- c("analysis_time_season_week")

awes_path <- find.package("awes")
target_loso_pred_res <- assemble_stacking_inputs(
  regions = region,
  prediction_target = prediction_target,
  component_model_names = c("kde", "kcde", "sarima"),
  explanatory_variables = explanatory_variables,
  include_model_performance = TRUE,
  preds_path = file.path(awes_path, "estimation/loso-predictions")
)

## get cross-validation groups
cv_folds <- lapply(unique(target_loso_pred_res$analysis_time_season),
  function(season_val) {
    which(target_loso_pred_res$analysis_time_season == season_val)
  })

require(doMC)
registerDoMC(4)

#debug(density_stack)
fit_formula <- as.formula(paste0(
  paste0(c("kde", "kcde", "sarima"), "_log_score", collapse = " + "),
  " ~ ",
  paste(explanatory_variables, collapse = " + ")))
fit_time_cv_reg <- system.time({
  stacking_fit_cv_reg <- density_stack(
    fit_formula,
    data = target_loso_pred_res,
    df = data.frame(
      analysis_time_season_week = c(2, seq(from = 5, by = 5, to = 30))
    ),
    min_obs_weight = 1,
    tol = 10^{-3},
    maxit = 10^5,
    cv_folds = cv_folds,
    verbose = 1)
})

stacking_fits_fixed_reg <- lapply(c(2, seq(from = 5, by = 5, to = 30)),
  function(df) {
    density_stack(
      fit_formula,
      data = target_loso_pred_res,
      df = df,
      min_obs_weight = 1,
      tol = 10^{-3},
      maxit = 10^5,
      cv_folds = cv_folds,
      verbose = 0)
  })
@

Estimation run time with leave-one-season-out cross-validation to compare spline
df values
<<FluModelsCVRunTime>>=
fit_time_cv_reg
@

Plot of cross-validation results
<<FluModelsOneFeatureCVResults, eval = TRUE, cache = TRUE>>=
plot_df <- stacking_fit_cv_reg$cv_results
plot_df$se <- apply(plot_df[, 2:13], 1, function(x) sd(x) / sqrt(12))
plot_df$lb <- plot_df$cv_log_score_mean - plot_df$se
plot_df$ub <- plot_df$cv_log_score_mean + plot_df$se

ggplot(plot_df) +
  geom_point(aes(x = analysis_time_season_week, y = cv_log_score_mean)) +
  geom_errorbar(aes(x = analysis_time_season_week, ymin = lb, ymax = ub)) +
  xlab("Spline df") +
  ylab("CV mean log score across seasons held out") +
  theme_bw()
@

Plot of weights from spline fits with different degrees of freedom -- best darker

<<FluModelsOneFeatureWeights, eval = TRUE, cache = TRUE>>=
get_legend_grob <- function(x) {
  data <- ggplot2:::ggplot_build(x)

  plot <- data$plot
  panel <- data$panel
  data <- data$data
  theme <- ggplot2:::plot_theme(plot)
  position <- theme$legend.position
  if (length(position) == 2) {
    position <- "manual"
  }

  legend_box <- if (position != "none") {
    ggplot2:::build_guides(plot$scales, plot$layers, plot$mapping,
      position, theme, plot$guides, plot$labels)
  } else {
    ggplot2:::zeroGrob()
  }
  if (ggplot2:::is.zero(legend_box)) {
    position <- "none"
  }
  else {
    legend_width <- gtable:::gtable_width(legend_box) + theme$legend.margin
    legend_height <- gtable:::gtable_height(legend_box) + theme$legend.margin
    just <- valid.just(theme$legend.justification)
    xjust <- just[1]
    yjust <- just[2]
    if (position == "manual") {
      xpos <- theme$legend.position[1]
      ypos <- theme$legend.position[2]
      legend_box <- editGrob(legend_box, vp = viewport(x = xpos,
        y = ypos, just = c(xjust, yjust), height = legend_height,
        width = legend_width))
    }
    else {
      legend_box <- editGrob(legend_box, vp = viewport(x = xjust,
        y = yjust, just = c(xjust, yjust)))
    }
  }
  return(legend_box)
}


## get resulting model weights at a grid of values for chosen explanatory variables
if("kcde_model_confidence" %in% explanatory_variables ||
    "sarima_model_confidence" %in% explanatory_variables) {
  if(identical(prediction_target, "peak_inc")) {
    model_confidence_grid <- seq(from = 1, to = 99, by = 2)
  } else if(identical(prediction_target, "onset")) {
    model_confidence_grid <- seq_len(34)
  } else {
    ## peak_week
    model_confidence_grid <- seq_len(33)
  }
} else {
  model_confidence_grid <- 1
}

if("weighted_ili" %in% explanatory_variables) {
  weighted_ili_grid <- seq(from = 0, to = 13, by = 0.5)
} else {
  weighted_ili_grid <- 1
}

typical_analysis_time_season_week <- 17L
if(prediction_target %in% c("onset", "peak_week")) {
  typical_model_confidence <- 5L
} else {
  typical_model_confidence <- 20L
}
typical_ili <- 2.5

newdata <- bind_rows(
  expand.grid(
    analysis_time_season_week = 10:40,
    kcde_model_confidence = model_confidence_grid,
    sarima_model_confidence = typical_model_confidence,
    weighted_ili = typical_ili,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = 10:40,
    kcde_model_confidence = typical_model_confidence,
    sarima_model_confidence = model_confidence_grid,
    weighted_ili = typical_ili,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = 10:40,
    kcde_model_confidence = typical_model_confidence,
    sarima_model_confidence = typical_model_confidence,
    weighted_ili = weighted_ili_grid,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = typical_analysis_time_season_week,
    kcde_model_confidence = model_confidence_grid,
    sarima_model_confidence = model_confidence_grid,
    weighted_ili = typical_ili,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = typical_analysis_time_season_week,
    kcde_model_confidence = model_confidence_grid,
    sarima_model_confidence = typical_model_confidence,
    weighted_ili = weighted_ili_grid,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = typical_analysis_time_season_week,
    kcde_model_confidence = typical_model_confidence,
    sarima_model_confidence = model_confidence_grid,
    weighted_ili = weighted_ili_grid,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE]
  ) %>%
  distinct()



model_weights <- compute_model_weights(stacking_fit_cv_reg,
  newdata = newdata,
  log = FALSE)

# model_weights <- compute_model_weights(stacking_fit_cv_fixed,
#     newdata = newdata,
#     log = FALSE)
colnames(model_weights) <- c("kde", "kcde", "sarima")
weights <- cbind(newdata,
  model_weights) %>% as.data.frame()

weights <- weights %>%
  gather_("model", "weight", c("kde", "kcde", "sarima"))

model_weights_fixed_reg <- lapply(stacking_fits_fixed_reg,
  function(stacking_fit) {
    model_weights_one_fit <- compute_model_weights(stacking_fit,
      newdata = newdata,
      log = FALSE)

    # model_weights <- compute_model_weights(stacking_fit_cv_fixed,
    #     newdata = newdata,
    #     log = FALSE)
    colnames(model_weights_one_fit) <- c("kde", "kcde", "sarima")
    weights_one_fit <- cbind(newdata,
      model_weights_one_fit) %>% as.data.frame()

    weights_one_fit <- weights_one_fit %>%
      gather_("model", "weight", c("kde", "kcde", "sarima"))
    weights_one_fit$df <- as.character(stacking_fit$spline_fits[[1]]$df)

    return(weights_one_fit)
  }) %>%
  rbind.fill()

  color_palette <- c("#E69F00", "#56B4E9", "#009E73")

  p_onset_weights <- ggplot() +
    geom_line(aes(x = analysis_time_season_week,
        y = weight,
        colour = model,
        linetype = model,
        group = factor(paste0(df, model))
      ),
      alpha = 0.4,
      data = model_weights_fixed_reg) +
    geom_line(aes(x = analysis_time_season_week,
        y = weight,
        colour = model,
        linetype = model
      ),
      size = 1.3,
      data = weights) +
  #  facet_wrap( ~ quantity) +
    scale_linetype("Model") +
    scale_colour_manual("Model", values = color_palette) +
    ylim(c(0,1)) +
    xlab("Week of Season at Analysis Time") +
  #  ylab("Model Weight") +
  #  ggtitle("B: Component Model Weights") +
    theme_bw(base_size = 11) +
    theme(axis.title.y = element_blank(),
#      legend.position = "none",
      plot.margin = unit(c(3, 6, 0, 5), "pt"))

print(p_onset_weights)
@

\newpage

Which spline df values resulted in fits approximately as good as the best?  All of them!
<<FluModelsOneFeatureWeightsCVTestResults>>=
cv_results <- stacking_fit_cv_reg$cv_results[, 2:13]
best_params_ind <- which.max(stacking_fit_cv_reg$cv_results[, 14])
cv_nfolds <- 12
sapply(seq_len(nrow(cv_results)),
  function(ind) {
    t.test(
      x = as.numeric(cv_results[ind, paste0("cv_log_score_fold_", seq_len(cv_nfolds))]),
      y = as.numeric(cv_results[best_params_ind, paste0("cv_log_score_fold_", seq_len(cv_nfolds))]),
      paired = TRUE
    )$p.value >= 0.05
  })
@

Plot of weights from spline fits with different degrees of freedom -- COMBINED darker

<<FluModelsOneFeatureWeightsCombined, eval = TRUE, cache = TRUE>>=

model_weights_fixed_reg <- lapply(stacking_fits_fixed_reg,
  function(stacking_fit) {
    model_weights_one_fit <- compute_model_weights(stacking_fit,
      newdata = newdata,
      log = FALSE)

    # model_weights <- compute_model_weights(stacking_fit_cv_fixed,
    #     newdata = newdata,
    #     log = FALSE)
    colnames(model_weights_one_fit) <- c("kde", "kcde", "sarima")
    weights_one_fit <- cbind(newdata,
      model_weights_one_fit) %>% as.data.frame()

    weights_one_fit <- weights_one_fit %>%
      gather_("model", "weight", c("kde", "kcde", "sarima"))
    weights_one_fit$df <- as.character(stacking_fit$spline_fits[[1]]$df)

    return(weights_one_fit)
  }) %>%
  rbind.fill()

weights <- model_weights_fixed_reg %>%
  group_by(analysis_time_season_week, model) %>%
  summarize(weight = mean(weight)) %>%
  ungroup()

  color_palette <- c("#E69F00", "#56B4E9", "#009E73")

  p_onset_weights <- ggplot() +
    geom_line(aes(x = analysis_time_season_week,
        y = weight,
        colour = model,
        linetype = model,
        group = factor(paste0(df, model))
      ),
      alpha = 0.4,
      data = model_weights_fixed_reg) +
    geom_line(aes(x = analysis_time_season_week,
        y = weight,
        colour = model,
        linetype = model
      ),
      size = 1.3,
      data = weights) +
  #  facet_wrap( ~ quantity) +
    scale_linetype("Model") +
    scale_colour_manual("Model", values = color_palette) +
    ylim(c(0,1)) +
    xlab("Week of Season at Analysis Time") +
  #  ylab("Model Weight") +
  #  ggtitle("B: Component Model Weights") +
    theme_bw(base_size = 11) +
    theme(axis.title.y = element_blank(),
#      legend.position = "none",
      plot.margin = unit(c(3, 6, 0, 5), "pt"))

print(p_onset_weights)
@


CODE NOT RUN:

<<FluModelsMultipleFeatures, eval = FALSE>>=
library(plyr)
library(tidyr)
library(dplyr)
library(densitystackr)
library(ggplot2)
library(awes)

region <- "National"
prediction_target <- "peak_inc"
explanatory_variables <- c("analysis_time_season_week", "kcde_model_confidence", "sarima_model_confidence")

awes_path <- find.package("awes")
target_loso_pred_res <- assemble_stacking_inputs(
  regions = region,
  prediction_target = prediction_target,
  component_model_names = c("kde", "kcde", "sarima"),
  explanatory_variables = explanatory_variables,
  include_model_performance = TRUE,
  preds_path = file.path(awes_path, "estimation/loso-predictions")
)

## get cross-validation groups
cv_folds <- lapply(unique(target_loso_pred_res$analysis_time_season),
  function(season_val) {
    which(target_loso_pred_res$analysis_time_season == season_val)
  })

require(doMC)
registerDoMC(4)

#debug(density_stack)
fit_formula <- as.formula(paste0(
  paste0(c("kde", "kcde", "sarima"), "_log_score", collapse = " + "),
  " ~ ",
  paste(explanatory_variables, collapse = " + ")))
fit_time_cv_reg <- system.time({
  stacking_fit_cv_reg <- density_stack(
    fit_formula,
    data = target_loso_pred_res,
    df = data.frame(
      analysis_time_season_week = seq(from = 5, by = 5, length = 5),
      kcde_model_confidence = seq(from = 5, by = 5, length = 5),
      sarima_model_confidence = seq(from = 5, by = 5, length = 5)
    ),
    min_obs_weight = 1,
    tol = 10^{-3},
    maxit = 10^5,
    cv_folds = cv_folds,
    verbose = 1)
})


fit_time_cv_fixed <- system.time({
  stacking_fit_cv_fixed <- density_stack(
    fit_formula,
    data = target_loso_pred_res,
    lambda = 1,
    min_obs_weight = 1,
    tol = 10^{-3},
    maxit = 10^5,
    verbose = 2)
})

## get resulting model weights at a grid of values for chosen explanatory variables
if("kcde_model_confidence" %in% explanatory_variables ||
    "sarima_model_confidence" %in% explanatory_variables) {
  if(identical(prediction_target, "peak_inc")) {
    model_confidence_grid <- seq(from = 1, to = 99, by = 2)
  } else if(identical(prediction_target, "onset")) {
    model_confidence_grid <- seq_len(34)
  } else {
    ## peak_week
    model_confidence_grid <- seq_len(33)
  }
} else {
  model_confidence_grid <- 1
}

if("weighted_ili" %in% explanatory_variables) {
  weighted_ili_grid <- seq(from = 0, to = 13, by = 0.5)
} else {
  weighted_ili_grid <- 1
}

typical_analysis_time_season_week <- 17L
if(prediction_target %in% c("onset", "peak_week")) {
  typical_model_confidence <- 5L
} else {
  typical_model_confidence <- 20L
}
typical_ili <- 2.5

newdata <- bind_rows(
  expand.grid(
    analysis_time_season_week = 10:40,
    kcde_model_confidence = model_confidence_grid,
    sarima_model_confidence = typical_model_confidence,
    weighted_ili = typical_ili,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = 10:40,
    kcde_model_confidence = typical_model_confidence,
    sarima_model_confidence = model_confidence_grid,
    weighted_ili = typical_ili,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = 10:40,
    kcde_model_confidence = typical_model_confidence,
    sarima_model_confidence = typical_model_confidence,
    weighted_ili = weighted_ili_grid,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = typical_analysis_time_season_week,
    kcde_model_confidence = model_confidence_grid,
    sarima_model_confidence = model_confidence_grid,
    weighted_ili = typical_ili,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = typical_analysis_time_season_week,
    kcde_model_confidence = model_confidence_grid,
    sarima_model_confidence = typical_model_confidence,
    weighted_ili = weighted_ili_grid,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE],
  expand.grid(
    analysis_time_season_week = typical_analysis_time_season_week,
    kcde_model_confidence = typical_model_confidence,
    sarima_model_confidence = model_confidence_grid,
    weighted_ili = weighted_ili_grid,
    stringsAsFactors = FALSE)[, explanatory_variables, drop = FALSE]
  ) %>%
  distinct()

model_weights <- compute_model_weights(stacking_fit_cv_fixed,
    newdata = newdata,
    log = FALSE)
colnames(model_weights) <- c("kde", "kcde", "sarima")
weights <- cbind(newdata,
  model_weights) %>% as.data.frame()

weights <- weights %>%
  gather_("model", "weight", c("kde", "kcde", "sarima"))

typical_season_week <- 17L
if(prediction_target %in% c("onset", "peak_week")) {
  typical_confidence <- 5L
} else {
  typical_confidence <- 20L
}

p1 <- ggplot(
  weights %>%
    filter(sarima_model_confidence == typical_confidence &
        kcde_model_confidence %% 2 == 1) %>%
    mutate(model = toupper(model))) +
  geom_raster(aes(x = analysis_time_season_week, y = kcde_model_confidence, fill = weight)) +
  scale_fill_gradient2("Model\nWeight",
    breaks = c(0, 0.25, 0.5, 0.75, 1),
    labels = as.character(c(0, 0.25, 0.5, 0.75, 1)),
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = 0.5) +
  facet_wrap(~ model, nrow = 1L) +
  xlab("Season Week at Analysis Time") +
  ylab("KCDE Model Uncertainty") +
  theme_bw()

plot_legend <- get_legend_grob(p1)

p1 <- p1 + theme(legend.position = "none")

p2 <- ggplot(
  weights %>%
    filter(kcde_model_confidence == typical_confidence &
        sarima_model_confidence %% 2 == 1) %>%
    mutate(model = toupper(model))) +
  geom_raster(aes(x = analysis_time_season_week, y = sarima_model_confidence, fill = weight)) +
  scale_fill_gradient2("Model\nWeight",
    breaks = c(0, 0.25, 0.5, 0.75, 1),
    labels = as.character(c(0, 0.25, 0.5, 0.75, 1)),
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = 0.5) +
  facet_wrap(~ model, nrow = 1L) +
  xlab("Season Week at Analysis Time") +
  ylab("SARIMA Model Uncertainty") +
  theme_bw() +
  theme(legend.position = "none")

p3 <- ggplot(
  weights %>%
    filter(
      analysis_time_season_week == typical_season_week &
      kcde_model_confidence %%2 == 1 &
      sarima_model_confidence %% 2 == 1) %>%
    mutate(model = toupper(model))) +
  geom_raster(aes(x = kcde_model_confidence, y = sarima_model_confidence, fill = weight)) +
  scale_fill_gradient2("Model\nWeight",
    breaks = c(0, 0.25, 0.5, 0.75, 1),
    labels = as.character(c(0, 0.25, 0.5, 0.75, 1)),
    low = "#b2182b",
    mid = "#f7f7f7",
    high = "#2166ac",
    midpoint = 0.5) +
  facet_wrap(~ model, nrow = 1L) +
  xlab("KCDE Model Uncertainty") +
  ylab("SARIMA Model Uncertainty") +
  theme_bw() +
  theme(legend.position = "none")


grid.newpage()
num_lines_text <- 1
pushViewport(viewport(layout =
    grid.layout(nrow = 6, ncol = 2,
      heights = unit(
        c(num_lines_text, 1, num_lines_text, 1, num_lines_text, 1),
        rep(c("lines", "null"), 3)),
      widths = unit(c(4, 1), c("null", "null")))))
grid.text("A: SARIMA Model Uncertainty Fixed at 20",
  x = unit(0, "npc"),
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))
grid.text("B: KCDE Model Uncertainty Fixed at 20",
  x = unit(0, "npc"),
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 3, layout.pos.col = 1:2))
grid.text("C: Season Week Fixed at 17",
  x = unit(0, "npc"),
  just = "left",
  gp = gpar(fontsize = 12),
  vp = viewport(layout.pos.row = 5, layout.pos.col = 1:2))

print(p1, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
print(p2, vp = viewport(layout.pos.row = 4, layout.pos.col = 1))
print(p3, vp = viewport(layout.pos.row = 6, layout.pos.col = 1))

pushViewport(viewport(layout.pos.row = 3:4, layout.pos.col = 2))
grid.draw(plot_legend)
upViewport()
@

\end{document}
